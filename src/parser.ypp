%{
#include <bits/stdc++.h>
#include "ast.h"
	using namespace std;
 extern "C" int yylex();
  extern int yyparse();
  extern FILE *yyin;
  extern int line_num;
  extern int errors;
  class prog* start = NULL;
   void yyerror(const char *s);
%}

%union
{
	int number;
	char* stringType;
	class prog *start;
	class fields_c *fields;
	class field_c *field;
	class vars_c *vars;
	class var_c *var;
	class meth_c *meth;
	class meths_c *meths;
	class args_c *ars;
	class arg_c *ar;
	class block_c *bl;
	class vars_d_c *vsd;
	class var_d_c *vd;
	class var_names_c *vr_names;
}
%start prom

%token CALLOUT STRING
%token <stringType> ID
%token <number> INT_LITERAL
%token <stringType> CHAR_LITERAL
%token <stringType> BOOL_LITERAL
%token <stringType> EQQ NQQ EQ
%token <stringType> AND OR NOT
%token <stringType> LT GT LE GE
%token <stringType> ADD SUB
%token <stringType> MUL DIV MOD 
%token OL CL OS CS CB OB
%token <stringType> TYPE VOID
%token CLASS PROGRAM SC COMMA
%token IF FOR BREAK CONTINUE ELSE RETURN
%token <stringType> PLUSONE SUBONE	

%type <start> prom
%type <fields> field_declarations
%type <field> field_declaration
%type <vars> variables;
%type <var> variable;
%type <meth> method_declaration;
%type <meths> method_declarations;
%type <ars> args;
%type <ar> arg;
%type <bl> block;
%type <vsd> var_declarations;
%type <vd> var_declaration;
%type <vr_names> var_names;

%left EQQ NQQ
%left AND OR
%left LT GT LE GE
%left ADD SUB
%left MUL DIV MOD
%left NOT


%%

prom : CLASS PROGRAM CB field_declarations method_declarations OB{$$ = new prog($4,$5);start =$$;}
	 | CLASS PROGRAM CB OB {$$ = new prog(); start = $$;}
	 | CLASS PROGRAM CB method_declarations OB{ $$ = new prog(NULL,$4);start = $$;}
	 | CLASS PROGRAM CB field_declarations  OB { $$ = new prog($4,NULL); start = $$;};


field_declarations : field_declaration SC { $$ = new fields_c(); $$->push_back($1);} 
					| field_declarations field_declaration SC { $1->push_back($2); $$=$1; 		printf("field_declarations done\n");};
				   

field_declaration  : TYPE variables { $$ = new field_c($1,$2);};


variables 		   : variable { $$ = new vars_c();$$->push_back($1);} 
					| variables COMMA variable { $1->push_back($3); $$ = $1;};


variable           : ID { $$ = new var_c($1);} 
					| ID CS INT_LITERAL OS { $$ = new var_c(string($1),$3); printf("dsff\n");};

method_declarations : method_declaration { $$ = new meths_c(); $$->push_back($1);}
					| method_declarations method_declaration { $1->push_back($2); $$ =$1;}

method_declaration  : TYPE ID args block {$$ = new meth_c($1,$2,$3,$4);} 
					| VOID ID args block {$$ = new meth_c($1,$2,$3,$4);}

args               : CL OL { $$ =  new args_c();}
					| CL TYPE ID OL { $$  =  new args_c($2,$3);}
					| CL TYPE ID arg OL { $$ = new args_c($2,$3); $$->push_back($4);};

arg                : COMMA TYPE ID { $$ = new arg_c($2,$3); }
					| COMMA TYPE ID arg { $4->push_back($2,$3); $$ = $4;};

block              : CB var_declarations statements OB 
				   | CB statements OB 
				   | CB var_declarations OB { $$ = new block_c($2);}
				   | CB OB { $$ = new block_c();}

var_declarations   : var_declaration SC { $$ = new vars_d_c($1);}
					| var_declaration SC var_declarations { $3->push_back($1); $$=$3;} ; 

var_declaration    : TYPE ID { $$ = new var_d_c($1,$2);} 
					| TYPE ID var_names { $$ = new var_d_c($1,$2); $$->push_back($3);};

var_names          : COMMA ID { $$ = new var_names_c(); $$->push_back($2);}
					| COMMA ID var_names { $3->push_back($2); $$ = $3;};

statements         : statement | statements statement;

statement: assignment
		 | function_call SC
		 | IF CL expr OL block
		 | IF CL expr OL block ELSE block  
		 | { printf("For loop starting\n");} FOR identifier EQ expr COMMA expr block 
		 | RETURN SC 
		 | RETURN expr SC 
		 | BREAK SC 
		 | CONTINUE SC 
		 | block;

assignment: location EQ {printf("EQUALS \n");} expr SC  
		  | location PLUSONE expr SC 
	      | location SUBONE expr SC;


function_call: ID CL pars OL
			 | CALLOUT CL STRING callout_args OL;

pars         : expr 
			 | pars COMMA expr;

identifier   : ID {printf("location:%s\n ",$1);}

location : ID {printf("location:%s\n ",$1);}
		 | ID CS expr OS;

callout_args: | callout_args COMMA callout_arg;

callout_arg: expr 
		   | STRING;

expr : CL expr OL 
	 |  location 
	 |  literal
	 |  expr SUB expr
	 |  expr OR expr
	 |  expr AND expr 
	 |  expr NQQ expr
	 |  expr EQQ expr
	 |  expr GE expr
	 |  expr LE expr
	 |  expr GT expr
	 |  expr LT expr
	 |  expr MOD expr
	 |  NOT expr
	 |  expr DIV expr 
	 |  expr MUL expr
	 |  expr ADD expr
	 |  SUB {printf("sub expression \n");} expr 
	 ;

literal : INT_LITERAL {printf("int literal \n");} | CHAR_LITERAL | BOOL_LITERAL;



%%

main(int argc, char **argv)
{
	if(argc == 1)
    {
		fprintf(stderr, "Store the input expressions in a file name and give it as a argument\n");
		exit(1);
	}
	printf("Parsing started\n");
	yyin = fopen(argv[1], "r");
	yyparse();

	dfs* df = new dfs();
	start->accept(df);
	printf("THE END\n");
}

void yyerror(const char *s)
{
	fprintf(stderr, "error: %s\n", s);
}